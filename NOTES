## Syntax and semantics

Numbers are accepted in both decimal and hex (0x) formats, positive and negative.

String literals are "foo bar"; :foo is also permitted if the string contains no whitespace. String literals evaluate to the address of the allocated string. This memory WILL NOT BE FREED AUTOMATICALLY. Unless passed to a function that frees it or takes ownership of it, it must be freed by the user.

(TODO: functions)

Everything else is a word. Words are executed immediately when read; if prefixed with &, the address of the word is put on the stack instead.


## Compiling C functions

:builtins.nf compile-to
Writes definitions to builtins.nf.c, declarations to builtins.nf.h, and static initializers for the dictionary to builtins.nf.words.

0 compile-to
Turns off compilation.

Compiling C: :dup { "push(peek());" } cdef
cdef pops the function, which should consist solely of string literals
grabs all the strings, joins them with \n
wraps them in a function definition and outputs them
So the whole thing ends up being:

    // builtins.nf.h
    void word_dup();

    // builtins.nf.words
    { NULL, word_dup_impl, word_dup_name, NEXT_IN_FLASH | NAME_IN_FLASH | SELF_IN_FLASH },

    // builtins.nf.c
    const PROGMEM char word_dup_name[] = "dup";
    void word_dup_impl() {
      push(peek());
    }

The compiled Word is duly entered into the dictionary, but the allocated strings that make up its body are freed and ->execute is relinked to `bye` (or, once we have it, `error`) -- this allows future function definitions in that session to find it, but makes it uncallable.

Compiling notforth: `:double { 2 * } defn`
defn does the usual thing, except if compiled for the host *and* compile-to is set, it also emits C code
.nf.h and .nf.words look the same except the latter has IS_WORDLIST set, but here's the .nf.c:

    void word_double() {
      push(2);
      word_X2A();
    }

It assumes that all functions, C or notforth, it can call directly rather than going through find_word()

Problem: how do we handle string literals? By the time push() sees them they're just a pointer, so we have to do something
different in the parser here. Defer that problem for now, but it'll be an issue later.

## Calling wordlists in flash

We don't need to worry about this, since even wordlist functions, if compiled on the host, turn into C functions.

## Compiling pointers to Words in flash

oh god
ok, so, we're compiling a thing, read a word, call find_word(), append that address to the buffer
EXCEPT
what if it's in flash? find_word() copies that to a temporary buffer, then returns the address of the buffer
so everything that's in flash ends up having the same address
we can add a new flag, like SELF_IN_FLASH, but that doesn't help us get the real address
there's also no way to reliably distinguish flash addresses from ram address
so here's a really dumb idea
assume that Words are always at least 2-aligned -- THIS TURNS OUT TO BE WRONG, THEY AREN'T, EVERYONE PANIC
then use the LSB of the address as an "in flash" bit
so, find_word returns the real address if in RAM, or (address | 0x01) if in flash
call_word checks if (address & 0x01) and copies it into a temporary buffer if so
buffer needs to be on the stack, otherwise we can't recurse
so, calling a word turns into
- check if low bit set; if so, clear it and copy from flash into ram
- if IS_CONSTANT, push
- if IS_WORDLIST, iterate execute, calling call_word() on each one
- otherwise just call word->execute()

Build process:
- anything with a .ino extension gets catted together, then Arduino headers are prepended, arduino preprocessor runs, *then* it gets fed to gcc. So stuff with arduino-specific code should go in .ino files.
- C files are compiled and then linked in to the final program. So stuff with multiplatform code should go in .c files.
- stuff with linux specific code should go in .c files guarded by #ifdef HOST_NOTFORTH


So, problem -- we only have 2k RAM and 1k EEPROM. We can't write flash while running, only the bootloader can do that. So anything we enter at the serial console has to be compiled and saved in RAM, and that doesn't give us a lot of space.

Solution: store as much stuff as we can in EEPROM. This doesn't help with stuff entered at the terminal but anything precompiled can go in EEPROM except the dictionary chain itself.

Problem: we can't store wordlists in EEPROM unless we're willing to eat a massive performance hit copying data out of flash every time we execute one. So EEPROM needs to contain actual C functions.

So -- we need a compiler that can run on the host and generate C code that then gets compiled for the target by avr-gcc, keeping only the dictionary chain in memory -- and then we need to run the whole thing on the target.

Also, we should be able to take wordlist definitions uploaded to the target at runtime and paste them into this compiler and get equivalent C out.

So, say we define a word pair, C{ }, that lets us define a word implemented in C.

If run on the target, it's an error. If run on the host, it emits C code to a file.

Similarly, {} if run on the target compiles a wordlist to RAM. If run on the host it emits C code to call the functions making up that wordlist.

This means we need a way of mapping words to valid C identifiers. Thought: word_<munged name>, where the name replaces non-alphanumerics with "X%02X" % char.

How do we build the dictionary chain in the generated C code?
We don't! Make it an array instead. Store (~0) as the pointer in each one after the first. It goes in .data and gets written to EEPROM. Make sure the flag NEXT_IN_FLASH is properly set for each one. At initialization time we should probably tack on one last one with NEXT_IN_FLASH set to make sure everything works properly.

// Top level loop:
// - read a word
//   - eat whitespace
//   - read first char
//   - if reader macro, invoke macro and let it handle the rest
//   - else read rest of word into lexer
// - if it's a literal, push it on the stack
// - if it's a word, execute it

// Executing a word:
// - find Word* w in the dict
// - w->execute(w)

// Question: how do we handle function definitions? I was thinking something like:
// > /inc { 1 + } def
// a la ps
// BUT
// if /inc implicitly creates a new entry, how do we refer to it as a first-
// class function?
// Maybe:
// > /inc makeword { 1 + } def
// where:
// makeword ( symbol -- word-pointer )
// def ( word-pointer code -- )
// But in that case, do we need a separate "symbol" type at all? Maybe we just
// have a string type:
// > "inc" makeword { 2 + } def
// and then have a reader macro to refer to a function without calling it,
// e.g.
// > 3 `inc apply

// How do we handle strings? One possibility is just to push them onto the stack
// directly, e.g [bytes of string] [alignment padding] [length of string]
// Of course, this means if you then call something that doesn't expect a string
// Or, god forbid, something that manipulates the stack like dup or exch
// CHAOS REIGNS
// the ans forth approach is to store [pointer to string] [length of string]
// and it's up to the interpreter to figure out where to store the string
// the string is probably read-only
// let's defer strings for now

