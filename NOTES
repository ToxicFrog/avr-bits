## Syntax and semantics

Numbers are accepted in both decimal and hex (0x) formats, positive and negative.

String literals are "foo bar"; :foo is also permitted if the string contains no whitespace. String literals evaluate to the address of the allocated string. This memory WILL NOT BE FREED AUTOMATICALLY. Unless passed to a function that frees it or takes ownership of it, it must be freed by the user.

(TODO: functions)

Everything else is a word. Words are executed immediately when read; if prefixed with &, the address of the word is put on the stack instead.

## writing C definitions for nf words

{, in addition to creating the Word, also begins a word_anon_<address> function
Each instruction compiled is then appended
} closes the function
defn can then emit:
  const PROGMEM char word_<mangled>_name = "...";
  #define word_<mangled>_impl word_anon_<address>
and
  { (Word*)1, word_<mangled>_impl, word_<mangled>_name, flags },
into the C.

Problem: how do we handle nested functions?
Assume we have a stack of function definitions.
Then when we finish one, } calls compile_addressof, which in nfbc is:
  OP_PUSHLITERAL,(Cell)word
and in C should be:
  push((Cell)word_anon_<address>);
as long as we call this *after* we've finalized and popped the current function source code,
we should be good.

## new input code

execute.c gets most of stacks.c and possibly some other things besides like execute_wordlist()
compile.c gets the new lexing/parsing code
basic operation is compile(string) which reads input and pushes opcodes onto the stack, then malloc()s room for them and moves them off the stack into the new buffer
we shouldn't need to change the code for { and }, although we can probably factor some bits out into a common function
So :double { 2 * } defn turns into:

PUSHLITERAL "double"
[create new word and add it to the compilation chain]
PUSHLITERAL 2
&*
[pop last three cells, store in word, push word, link word into dict]
&defn

Since { and } are immediate, that leaves the stack as:
PUSHLITERAL "double" <address of anonymous word> &defn
reaching EOF, compile() then pops this into a wordlist -- either malloc'd or a static buffer, although in the latter case we can probably write to the buffer directly rather than using the stack -- and then the caller can execute_wordlist() it and then free it.


// I guess if it's a word, we end up calling compile_word, which emits the
// appropriate C code; either
// word_mangled_name_impl() // C word
// execute_word(word_mangled_name_impl) // notforth word
// that still leaves consts but I guess we shouldn't be defining consts in flash
// that may depend on the system! Like all the registers and stuff should be const
// but should also only be available in AVR, and stuff that needs to be preallocated
// should be created in __init__
// although then we can't have a const pointer to a static buffer, can we? Hrm
// I mean, I guess we can have c/const
// which is similar to c/defn except it emits:
// Cell word_mangled_name_const = (Cell)(<expr>);
// so you can do something like
// "char inbuf[80];" c/emit
// :inbuf "inbuf" c/const
// and the dict entry has IS_CONSTANT | IS_IMMEDIATE set?
// although I guess in that case we don't even need the word_mangled_name_const, it
// just turns into:
// { (Word*)1, (WordImpl)(<expr>), word_mangled_name, IS_CONSTANT | IS_IMMEDIATE | ... },
// and then it points to the right thing at compile time
// how do we handle EOF?
// when reading from a file this is just "when we're at the end of the file"
// when reading keyboard input, I guess it's at EOL when the lexing state and compiler
// state are both idle?

When compile() runs out of input, or when it runs out of space to compile to, it returns. This presumably means it needs a way to communicate to the caller how far it got -- or it needs to use a stateful input source.

Say, something like:
WordList compile(char (*next)(void*), void* data)
and it repeatedly calls next(data) to get the next character, with the expectation that it will return EOF on eof
so for file input this is just fgetc and the FILE*
for serial input it's a wrapper around ReadByte that returns EOF on \n
for tty input it's a wrapper around getchar() that behaves similarly

## Compiling C functions

:foo.nf c/file

Opens foo.nf.dict and foo.nf.impl

:foo { "bar();" "baz();" } c/def

Defines foo as an error word and writes the real implementation to foo.nf.impl; recompile notforth to get it

TODO: if the function is already defined, write the implementation but do not register the word in the dictionary.

0 c/file

Closes the .impl and .dict. Run `make` to incorporate the new words.


Compiling notforth to C

As a wordlist it's going to be a bunch of:
- PUSHLITERAL n => push(n)
- CALLWORD word => word_<mangled_name>_impl();
- <function pointer> => word_<mangled_name(fpointer_to_word(fp)->name)_impl();

This works because, if the target word is a wordlist, we nonetheless know that it's available as a C function (because it's part of the bootstrapping process). If it's not a wordlist, we walk the dictionary to figure out which word the function corresponds to and derive the function name from that.

Problem: how do we handle string literals? By the time push() sees them they're just a pointer, so we have to do something
different in the parser here. Defer that problem for now, but it'll be an issue later.

## Calling wordlists in flash

We don't need to worry about this, since even wordlist functions, if compiled on the host, turn into C functions.

## Compiling pointers to Words in flash

oh god
ok, so, we're compiling a thing, read a word, call find_word(), append that address to the buffer
EXCEPT
what if it's in flash? find_word() copies that to a temporary buffer, then returns the address of the buffer
so everything that's in flash ends up having the same address
we can add a new flag, like SELF_IN_FLASH, but that doesn't help us get the real address
there's also no way to reliably distinguish flash addresses from ram address
so here's a really dumb idea
assume that Words are always at least 2-aligned -- THIS TURNS OUT TO BE WRONG, THEY AREN'T, EVERYONE PANIC
then use the LSB of the address as an "in flash" bit
so, find_word returns the real address if in RAM, or (address | 0x01) if in flash
call_word checks if (address & 0x01) and copies it into a temporary buffer if so
buffer needs to be on the stack, otherwise we can't recurse
so, calling a word turns into
- check if low bit set; if so, clear it and copy from flash into ram
- if IS_CONSTANT, push
- if IS_WORDLIST, iterate execute, calling call_word() on each one
- otherwise just call word->execute()

Build process:
- anything with a .ino extension gets catted together, then Arduino headers are prepended, arduino preprocessor runs, *then* it gets fed to gcc. So stuff with arduino-specific code should go in .ino files.
- C files are compiled and then linked in to the final program. So stuff with multiplatform code should go in .c files.
- stuff with linux specific code should go in .c files guarded by #ifdef HOST_NOTFORTH


So, problem -- we only have 2k RAM and 1k EEPROM. We can't write flash while running, only the bootloader can do that. So anything we enter at the serial console has to be compiled and saved in RAM, and that doesn't give us a lot of space.

Solution: store as much stuff as we can in EEPROM. This doesn't help with stuff entered at the terminal but anything precompiled can go in EEPROM except the dictionary chain itself.

Problem: we can't store wordlists in EEPROM unless we're willing to eat a massive performance hit copying data out of flash every time we execute one. So EEPROM needs to contain actual C functions.

So -- we need a compiler that can run on the host and generate C code that then gets compiled for the target by avr-gcc, keeping only the dictionary chain in memory -- and then we need to run the whole thing on the target.

Also, we should be able to take wordlist definitions uploaded to the target at runtime and paste them into this compiler and get equivalent C out.

So, say we define a word pair, C{ }, that lets us define a word implemented in C.

If run on the target, it's an error. If run on the host, it emits C code to a file.

Similarly, {} if run on the target compiles a wordlist to RAM. If run on the host it emits C code to call the functions making up that wordlist.

This means we need a way of mapping words to valid C identifiers. Thought: word_<munged name>, where the name replaces non-alphanumerics with "X%02X" % char.

How do we build the dictionary chain in the generated C code?
We don't! Make it an array instead. Store (~0) as the pointer in each one after the first. It goes in .data and gets written to EEPROM. Make sure the flag NEXT_IN_FLASH is properly set for each one. At initialization time we should probably tack on one last one with NEXT_IN_FLASH set to make sure everything works properly.
